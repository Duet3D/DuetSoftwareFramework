using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DuetAPI.ObjectModel
{
    /// <summary>
    /// Representation of the full machine model as maintained by DCS
    /// </summary>
    [JsonConverter(typeof(ObjectModelConverter))]
    public sealed class ObjectModel : ModelObject
    {
        /// <summary>
        /// List of connected boards
        /// </summary>
        /// <seealso cref="Board"/>
        /// <remarks>
        /// The first item represents the main board
        /// </remarks>
        public ModelCollection<Board> Boards { get; } = new ModelCollection<Board>();

        /// <summary>
        /// Information about the individual directories
        /// </summary>
        /// <remarks>
        /// This may not be available in RepRapFirmware if no mass storages are available
        /// </remarks>
        public Directories Directories { get; } = new Directories();

        /// <summary>
        /// List of configured fans
        /// </summary>
        /// <seealso cref="Fan"/>
        public ModelCollection<Fan> Fans { get; } = new ModelCollection<Fan>();

        /// <summary>
        /// Dictionary of global variables vs JSON values
        /// </summary>
        /// <remarks>
        /// When DSF attempts to reconnect to RRF, this may be set to null to clear the contents
        /// </remarks>
        public ModelDictionary<JsonElement> Global { get; } = new ModelDictionary<JsonElement>(false);

        /// <summary>
        /// Information about the heat subsystem
        /// </summary>
        public Heat Heat { get; } = new Heat();

        /// <summary>
        /// List of registered third-party HTTP endpoints
        /// </summary>
        [SbcProperty(false)]
        public ModelCollection<HttpEndpoint> HttpEndpoints { get; } = new ModelCollection<HttpEndpoint>();

        /// <summary>
        /// Information about every available G/M/T-code channel
        /// </summary>
        public Inputs Inputs { get; } = new Inputs();

        /// <summary>
        /// Information about the current job
        /// </summary>
        public Job Job { get; } = new Job();

        /// <summary>
        /// Machine configuration limits
        /// </summary>
        public Limits Limits { get; } = new Limits();

        /// <summary>
        /// Generic messages that do not belong explicitly to codes being executed.
        /// This includes status messages, generic errors and outputs generated by M118
        /// </summary>
        /// <seealso cref="Message"/>
        [SbcProperty(false)]
        public ModelGrowingCollection<Message> Messages { get; } = new ModelGrowingCollection<Message>();

        /// <summary>
        /// Information about the move subsystem
        /// </summary>
        public Move Move { get; } = new Move();

        /// <summary>
        /// Information about connected network adapters
        /// </summary>
        public Network Network { get; } = new Network();

        /// <summary>
        /// Dictionary of SBC plugins where each key is the plugin identifier
        /// </summary>
        /// <remarks>
        /// Values in this dictionary cannot become null. If a change to null is reported, the corresponding key is deleted.
        /// Do not rely on the setter of this property; it will be removed from a future version.
        /// </remarks>
        [SbcProperty(false)]
        public ModelDictionary<Plugin> Plugins { get; } = new ModelDictionary<Plugin>(true);

        /// <summary>
        /// Information about the 3D scanner subsystem
        /// </summary>
        [SbcProperty(true)]
        public Scanner Scanner { get; } = new Scanner();
        
        /// <summary>
        /// Information about connected sensors including Z-probes and endstops
        /// </summary>
        public Sensors Sensors { get; } = new Sensors();
        
        /// <summary>
        /// List of configured CNC spindles
        /// </summary>
        /// <seealso cref="Spindle"/>
        public ModelCollection<Spindle> Spindles { get; } = new ModelCollection<Spindle>();
        
        /// <summary>
        /// Information about the machine state
        /// </summary>
        public State State { get; } = new State();
        
        /// <summary>
        /// List of configured tools
        /// </summary>
        /// <seealso cref="Tool"/>
        public ModelCollection<Tool> Tools { get; } = new ModelCollection<Tool>();

        /// <summary>
        /// List of user sessions
        /// </summary>
        [SbcProperty(false)]
        public ModelCollection<UserSession> UserSessions { get; } = new ModelCollection<UserSession>();

        /// <summary>
        /// List of user-defined variables
        /// </summary>
        /// <seealso cref="UserVariable"/>
        [JsonIgnore]
        [Obsolete("Do not use this field. The underlying type may be changed to MutableModelDictionary in a future update")]
        public ModelCollection<UserVariable> UserVariables { get; } = new ModelCollection<UserVariable>();

        /// <summary>
        /// List of available mass storages
        /// </summary>
        /// <seealso cref="Volume"/>
        [SbcProperty(true)]
        public ModelCollection<Volume> Volumes { get; } = new ModelCollection<Volume>();

        /// <summary>
        /// Update this instance from a given JSON element
        /// </summary>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromModel(JsonElement jsonElement) => InternalUpdateFromModel(null, jsonElement, false);

        /// <summary>
        /// Update a specific key of this instance from a given JSON element as provided by the firmware
        /// </summary>
        /// <param name="key">Property name to update</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <param name="offset">Index offset</param>
        /// <param name="last">Whether this is the last update</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromFirmwareModel(string key, JsonElement jsonElement, int offset = 0, bool last = true) => InternalUpdateFromModel(key, jsonElement, true, offset, last);

        /// <summary>
        /// Update a specific key of this instance from a given JSON element
        /// </summary>
        /// <param name="key">Property name to update</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromModel(string key, JsonElement jsonElement) => InternalUpdateFromModel(key, jsonElement, false);

        /// <summary>
        /// Update the whole or a specific key of this instance from a given JSON element
        /// </summary>
        /// <param name="key">Property name to update or null if the whole object model is supposed to be updated</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <param name="ignoreSbcProperties">Whether SBC properties are ignored</param>
        /// <param name="offset">Index offset (collection keys only)</param>
        /// <param name="last">Whether this is the last update (collection keys only)</param>
        /// <returns>Whether the key could be updated</returns>
        private bool InternalUpdateFromModel(string key, JsonElement jsonElement, bool ignoreSbcProperties, int offset = 0, bool last = true)
        {
            if (string.IsNullOrEmpty(key))
            {
                UpdateFromJson(jsonElement, ignoreSbcProperties);
                return true;
            }

            if (JsonProperties.TryGetValue(key, out PropertyInfo property))
            {
                if (ignoreSbcProperties && Attribute.IsDefined(property, typeof(SbcPropertyAttribute)))
                {
                    // Skip this field if it must not be updated from RRF
                    return true;
                }

                object propertyValue = property.GetValue(this);
                if (propertyValue is IModelCollection modelCollection)
                {
                    modelCollection.UpdateFromJson(jsonElement, ignoreSbcProperties, offset, last);
                    return true;
                }
                if (propertyValue is IModelObject modelObject)
                {
                    modelObject.UpdateFromJson(jsonElement, ignoreSbcProperties);
                    return true;
                }

#if VERIFY_OBJECT_MODEL
                Console.WriteLine("[warn] Missing key type handler for {0}", key);
            }
            else
            {
                Console.WriteLine("[warn] Missing property: {0} = {1}", key, jsonElement.GetRawText());
#endif
            }

            // Failed to find a property
            return false;
        }

        /// <summary>
        /// Convert this instance to a JSON text
        /// </summary>
        /// <returns>JSON object</returns>
        public override string ToString() => JsonSerializer.Serialize(this, Utility.JsonHelper.DefaultJsonOptions);

        /// <summary>
        /// Serialize this instance to a UTF-8 string
        /// </summary>
        /// <returns></returns>
        public byte[] ToUtf8Json() => JsonSerializer.SerializeToUtf8Bytes(this, Utility.JsonHelper.DefaultJsonOptions);
    }

    /// <summary>
    /// Class used to convert model objects to and from JSON
    /// </summary>
    public class ObjectModelConverter : JsonConverter<ObjectModel>
    {
        /// <summary>
        /// Read a machine model object from a JSON reader
        /// </summary>
        /// <param name="reader">JSON reader</param>
        /// <param name="typeToConvert">Target type</param>
        /// <param name="options">JSON options</param>
        /// <returns>Machine model</returns>
        public override ObjectModel Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            using JsonDocument jsonDocument = JsonDocument.ParseValue(ref reader);
            if (jsonDocument.RootElement.ValueKind == JsonValueKind.Null)
            {
                return null;
            }

            ObjectModel machineModel = new();
            machineModel.UpdateFromJson(jsonDocument.RootElement, false);
            return machineModel;
        }

        /// <summary>
        /// Write a machine model to a JSON writer
        /// </summary>
        /// <param name="writer">JSON writer</param>
        /// <param name="value">Machine model</param>
        /// <param name="options">JSON options</param>
        public override void Write(Utf8JsonWriter writer, ObjectModel value, JsonSerializerOptions options)
        {
            if (value == null)
            {
                writer.WriteNullValue();
            }
            else
            {
                writer.WriteStartObject();
                foreach (KeyValuePair<string, PropertyInfo> jsonProperty in value.JsonProperties)
                {
                    writer.WritePropertyName(jsonProperty.Key);
                    JsonSerializer.Serialize(writer, jsonProperty.Value.GetValue(value), jsonProperty.Value.PropertyType, options);
                }
                writer.WriteEndObject();
            }
        }
    }
}