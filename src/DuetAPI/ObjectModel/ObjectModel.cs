using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DuetAPI.ObjectModel
{
    /// <summary>
    /// Representation of the Duet3D object model
    /// </summary>
    [JsonConverter(typeof(ObjectModelConverter))]
    public class ObjectModel : ModelObject
    {
        /// <summary>
        /// List of connected boards
        /// </summary>
        /// <seealso cref="Board"/>
        /// <remarks>
        /// The first item represents the main board
        /// </remarks>
        public ModelCollection<Board> Boards { get; } = new ModelCollection<Board>();

        /// <summary>
        /// Information about the individual directories
        /// </summary>
        /// <remarks>
        /// This may not be available in RepRapFirmware if no mass storages are available
        /// </remarks>
        public Directories Directories { get; } = new Directories();

        /// <summary>
        /// List of configured fans
        /// </summary>
        /// <seealso cref="Fan"/>
        public ModelCollection<Fan?> Fans { get; } = new ModelCollection<Fan?>();

        /// <summary>
        /// Dictionary of global variables vs JSON values
        /// </summary>
        /// <remarks>
        /// When DSF attempts to reconnect to RRF, this may be set to null to clear the contents
        /// </remarks>
        public ModelDictionary<JsonElement> Global { get; } = new ModelDictionary<JsonElement>(false);

        /// <summary>
        /// Information about the heat subsystem
        /// </summary>
        public Heat Heat { get; } = new Heat();

        /// <summary>
        /// Information about every available G/M/T-code channel
        /// </summary>
        public Inputs Inputs { get; } = new Inputs();

        /// <summary>
        /// Information about the current job
        /// </summary>
        public Job Job { get; } = new Job();

        /// <summary>
        /// List of configured LED strips
        /// </summary>
        public ModelCollection<LedStrip> LedStrips { get; } = new ModelCollection<LedStrip>();

        /// <summary>
        /// Machine configuration limits
        /// </summary>
        public Limits Limits { get; } = new Limits();

        /// <summary>
        /// Generic messages that do not belong explicitly to codes being executed.
        /// This includes status messages, generic errors and outputs generated by M118
        /// </summary>
        /// <seealso cref="Message"/>
        [SbcProperty(false)]
        public ModelGrowingCollection<Message> Messages { get; } = new ModelGrowingCollection<Message>();

        /// <summary>
        /// Information about the move subsystem
        /// </summary>
        public Move Move { get; } = new Move();

        /// <summary>
        /// Information about connected network adapters
        /// </summary>
        public Network Network { get; } = new Network();

        /// <summary>
        /// Dictionary of loaded plugins where each key is the plugin identifier
        /// </summary>
        /// <remarks>
        /// This is only populated by DSF in SBC mode, however it may be populated manually as well in standalone mode.
        /// Values in this dictionary cannot become null. If a value is changed to null, the corresponding item is deleted
        /// </remarks>
        [SbcProperty(false)]
        public ModelDictionary<Plugin> Plugins { get; } = new ModelDictionary<Plugin>(true);

        /// <summary>
        /// Information about the SBC which Duet Software Framework is running on.
        /// This is null if the system is operating in standalone mode
        /// </summary>
        [SbcProperty(false)]
        public SBC? SBC
        {
            get => _sbc;
            set => SetPropertyValue(ref _sbc, value);
        }
        private SBC? _sbc = new();

        /// <summary>
        /// Information about connected sensors including Z-probes and endstops
        /// </summary>
        public Sensors Sensors { get; } = new Sensors();
        
        /// <summary>
        /// List of configured CNC spindles
        /// </summary>
        /// <seealso cref="Spindle"/>
        public ModelCollection<Spindle?> Spindles { get; } = new ModelCollection<Spindle?>();
        
        /// <summary>
        /// Information about the machine state
        /// </summary>
        public State State { get; } = new State();
        
        /// <summary>
        /// List of configured tools
        /// </summary>
        /// <seealso cref="Tool"/>
        public ModelCollection<Tool?> Tools { get; } = new ModelCollection<Tool?>();

        /// <summary>
        /// List of user sessions
        /// </summary>
        [SbcProperty(false)]
        public ModelCollection<UserSession> UserSessions { get; } = new ModelCollection<UserSession>();

        /// <summary>
        /// List of available mass storages
        /// </summary>
        /// <seealso cref="Volume"/>
        [SbcProperty(true)]
        public ModelCollection<Volume> Volumes { get; } = new ModelCollection<Volume>();

        /// <summary>
        /// Update a specific key of this instance from a given JSON element as provided by the firmware
        /// </summary>
        /// <param name="key">Property name to update</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <param name="offset">Index offset</param>
        /// <param name="last">Whether this is the last update</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromFirmwareJson(string? key, JsonElement jsonElement, int offset = 0, bool last = true) => InternalUpdateFromJson(key, jsonElement, true, offset, last);

        /// <summary>
        /// Update this instance from a given JSON element
        /// </summary>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromJson(JsonElement jsonElement) => InternalUpdateFromJson(null, jsonElement, false);

        /// <summary>
        /// Update a specific key of this instance from a given JSON element
        /// </summary>
        /// <param name="key">Property name to update</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromJson(string key, JsonElement jsonElement) => InternalUpdateFromJson(key, jsonElement, false);

        /// <summary>
        /// Update the whole or a specific key of this instance from a given JSON element
        /// </summary>
        /// <param name="key">Property name to update or null if the whole object model is supposed to be updated</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <param name="ignoreSbcProperties">Whether SBC properties are ignored</param>
        /// <param name="offset">Index offset (collection keys only)</param>
        /// <param name="last">Whether this is the last update (collection keys only)</param>
        /// <returns>Whether the key could be updated</returns>
        private bool InternalUpdateFromJson(string? key, JsonElement jsonElement, bool ignoreSbcProperties, int offset = 0, bool last = true)
        {
            if (string.IsNullOrEmpty(key))
            {
                UpdateFromJson(jsonElement, ignoreSbcProperties);
                return true;
            }

            if (JsonProperties.TryGetValue(key!, out PropertyInfo? property))
            {
                if (ignoreSbcProperties && Attribute.IsDefined(property, typeof(SbcPropertyAttribute)))
                {
                    // Skip this field if it must not be updated from RRF
                    return true;
                }

                object? propertyValue = property.GetValue(this);
                if (propertyValue is IModelCollection modelCollection)
                {
                    modelCollection.UpdateFromJson(jsonElement, ignoreSbcProperties, offset, last);
                    return true;
                }
                if (propertyValue is IModelObject modelObject)
                {
                    modelObject.UpdateFromJson(jsonElement, ignoreSbcProperties);
                    return true;
                }

#if VERIFY_OBJECT_MODEL
                Console.WriteLine("[warn] Missing key type handler for {0}", key);
            }
            else
            {
                Console.WriteLine("[warn] Missing property: {0} = {1}", key, jsonElement.GetRawText());
#endif
            }

            // Failed to find a property
            return false;
        }

        /// <summary>
        /// Convert this instance to a JSON text
        /// </summary>
        /// <returns>JSON object</returns>
        public override string ToString() => JsonSerializer.Serialize(this, Utility.JsonHelper.DefaultJsonOptions);

        /// <summary>
        /// Serialize this instance to a UTF-8 string
        /// </summary>
        /// <returns></returns>
        public byte[] ToUtf8Json() => JsonSerializer.SerializeToUtf8Bytes(this, Utility.JsonHelper.DefaultJsonOptions);

        /// <summary>
        /// Static event to be called when the deserialization of a property failed.
        /// If an event handler is assigned, potential JsonExceptions are suppressed and the event is called instead
        /// </summary>
        public static event DeserializationFailedEventHandler? OnDeserializationFailed;

        /// <summary>
        /// Internal function to be called when the deserialization of a sub-property failed
        /// </summary>
        /// <param name="sender">Object that caused the exception</param>
        /// <param name="type">Type of the object that could not be deserialized</param>
        /// <param name="jsonValue">JSON data</param>
        /// <param name="e">Exception that caused the error</param>
        /// <returns>True if the exception can be suppressed</returns>
        internal static bool DeserializationFailed(object sender, Type type, JsonElement jsonValue, JsonException e)
        {
            if (OnDeserializationFailed is null)
            {
                return false;
            }
            OnDeserializationFailed.Invoke(sender, new DeserializationFailedEventArgs(type, jsonValue, e));
            return true;
        }
    }

    /// <summary>
    /// Delegate of the event to be called when deserialization of a property fails
    /// </summary>
    /// <param name="sender">Instance of the object that tried to deserialize a value`</param>
    /// <param name="e">Event arguments pointing to the property that failed to be deserialized</param>
    public delegate void DeserializationFailedEventHandler(object sender, DeserializationFailedEventArgs e);

    /// <summary>
    /// Event arguments for the event to be called when deserialization fails
    /// </summary>
    public sealed class DeserializationFailedEventArgs : EventArgs
    {
        /// <summary>
        /// Constructor of this class
        /// </summary>
        /// <param name="type">Type that failed to be deserialized</param>
        /// <param name="jsonValue">Data that failed to be deserialized</param>
        /// <param name="e">Exception that caused the deserialization to fail</param>
        public DeserializationFailedEventArgs(Type type, JsonElement jsonValue, Exception e)
        {
            TargetType = type;
            JsonValue = jsonValue;
            Exception = e;
        }

        /// <summary>
        /// Type that failed to be deserialized
        /// </summary>
        public Type TargetType { get; private set; }

        /// <summary>
        /// Data that failed to be deserialized
        /// </summary>
        public JsonElement JsonValue { get; private set; }

        /// <summary>
        /// Exception that caused the deserialization to fail
        /// </summary>
        public Exception Exception { get; private set; }
    }

    /// <summary>
    /// Class used to convert model objects to and from JSON
    /// </summary>
    public class ObjectModelConverter : JsonConverter<ObjectModel>
    {
        /// <summary>
        /// Read a machine model object from a JSON reader
        /// </summary>
        /// <param name="reader">JSON reader</param>
        /// <param name="typeToConvert">Target type</param>
        /// <param name="options">JSON options</param>
        /// <returns>Machine model</returns>
        public override ObjectModel? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            using JsonDocument jsonDocument = JsonDocument.ParseValue(ref reader);
            if (jsonDocument.RootElement.ValueKind == JsonValueKind.Null)
            {
                return null;
            }

            ObjectModel machineModel = new();
            machineModel.UpdateFromJson(jsonDocument.RootElement, false);
            return machineModel;
        }

        /// <summary>
        /// Write a machine model to a JSON writer
        /// </summary>
        /// <param name="writer">JSON writer</param>
        /// <param name="value">Machine model</param>
        /// <param name="options">JSON options</param>
        public override void Write(Utf8JsonWriter writer, ObjectModel value, JsonSerializerOptions options)
        {
            if (value is null)
            {
                writer.WriteNullValue();
            }
            else
            {
                writer.WriteStartObject();
                foreach (KeyValuePair<string, PropertyInfo> jsonProperty in value.JsonProperties)
                {
                    writer.WritePropertyName(jsonProperty.Key);
                    JsonSerializer.Serialize(writer, jsonProperty.Value.GetValue(value), jsonProperty.Value.PropertyType, options);
                }
                writer.WriteEndObject();
            }
        }
    }
}