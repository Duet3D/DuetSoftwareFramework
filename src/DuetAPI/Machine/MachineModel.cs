using System;
using System.Collections;
using System.Reflection;
using System.Text.Json;

namespace DuetAPI.Machine
{
    /// <summary>
    /// Representation of the full machine model as maintained by DCS
    /// </summary>
    public sealed class MachineModel : ModelObject
    {
        /// <summary>
        /// List of connected boards
        /// </summary>
        /// <seealso cref="Board"/>
        /// <remarks>
        /// The first item represents the main board
        /// </remarks>
        public ModelCollection<Board> Boards { get; } = new ModelCollection<Board>();

        /// <summary>
        /// Information about the individual directories
        /// </summary>
        /// <remarks>
        /// This may not be available in RepRapFirmware if no mass storages are available
        /// </remarks>
        public Directories Directories { get; } = new Directories();

        /// <summary>
        /// List of configured fans
        /// </summary>
        /// <seealso cref="Fan"/>
        public ModelCollection<Fan> Fans { get; } = new ModelCollection<Fan>();

        /// <summary>
        /// Information about the heat subsystem
        /// </summary>
        public Heat Heat { get; } = new Heat();

        /// <summary>
        /// List of registered third-party HTTP endpoints
        /// </summary>
        public ModelCollection<HttpEndpoint> HttpEndpoints { get; } = new ModelCollection<HttpEndpoint>();

        /// <summary>
        /// Information about every available G/M/T-code channel
        /// </summary>
        public Inputs Inputs { get; } = new Inputs();

        /// <summary>
        /// Information about the current job
        /// </summary>
        public Job Job { get; } = new Job();

        /// <summary>
        /// Machine configuration limits
        /// </summary>
        public Limits Limits { get; } = new Limits();
        
        /// <summary>
        /// Generic messages that do not belong explicitly to codes being executed.
        /// This includes status messages, generic errors and outputs generated by M118
        /// </summary>
        /// <seealso cref="Message"/>
        public ModelGrowingCollection<Message> Messages { get; } = new ModelGrowingCollection<Message>();
        
        /// <summary>
        /// Information about the move subsystem
        /// </summary>
        public Move Move { get; } = new Move();
        
        /// <summary>
        /// Information about connected network adapters
        /// </summary>
        public Network Network { get; } = new Network();
        
        /// <summary>
        /// Information about the 3D scanner subsystem
        /// </summary>
        [LinuxProperty]
        public Scanner Scanner { get; } = new Scanner();
        
        /// <summary>
        /// Information about connected sensors including Z-probes and endstops
        /// </summary>
        public Sensors Sensors { get; } = new Sensors();
        
        /// <summary>
        /// List of configured CNC spindles
        /// </summary>
        /// <seealso cref="Spindle"/>
        public ModelCollection<Spindle> Spindles { get; } = new ModelCollection<Spindle>();
        
        /// <summary>
        /// Information about the machine state
        /// </summary>
        public State State { get; } = new State();
        
        /// <summary>
        /// List of configured tools
        /// </summary>
        /// <seealso cref="Tool"/>
        public ModelCollection<Tool> Tools { get; } = new ModelCollection<Tool>();

        /// <summary>
        /// List of user sessions
        /// </summary>
        public ModelCollection<UserSession> UserSessions { get; } = new ModelCollection<UserSession>();

        /// <summary>
        /// List of user-defined variables
        /// </summary>
        /// <seealso cref="UserVariable"/>
        public ModelCollection<UserVariable> UserVariables { get; } = new ModelCollection<UserVariable>();

        /// <summary>
        /// List of available mass storages
        /// </summary>
        /// <seealso cref="Volume"/>
        [LinuxProperty]
        public ModelCollection<Volume> Volumes { get; } = new ModelCollection<Volume>();

        /// <summary>
        /// Update a specific key of this instance from a given JSON element as provided by the firmware
        /// </summary>
        /// <param name="key">Property name to update</param>
        /// <param name="jsonElement">Element to update this intance from</param>
        /// <returns>Whether the key could be updated</returns>
        public bool UpdateFromFirmwareModel(string key, JsonElement jsonElement)
        {
            if (string.IsNullOrEmpty(key))
            {
                UpdateFromJson(jsonElement, true);
                return true;
            }

            if (JsonProperties.TryGetValue(key, out PropertyInfo property))
            {
                if (Attribute.IsDefined(property, typeof(LinuxPropertyAttribute)))
                {
                    // Skip this field if it must not be updated from RRF
                    return true;
                }

                if (property.PropertyType.IsSubclassOf(typeof(ModelObject)))
                {
                    ModelObject value = (ModelObject)property.GetValue(this);
                    value.UpdateFromJson(jsonElement, true);
                    return true;
                }

                if (ModelCollection.GetItemType(property.PropertyType, out Type itemType))
                {
                    IList modelCollection = (IList)property.GetValue(this);
                    if (ModelGrowingCollection.TypeMatches(property.PropertyType))
                    {
                        ModelGrowingCollectionHelper.UpdateFromJson(modelCollection, itemType, jsonElement, true);
                    }
                    else
                    {
                        ModelCollectionHelper.UpdateFromJson(modelCollection, itemType, jsonElement, true);
                    }
                    return true;
                }

#if VERIFY_OBJECT_MODEL
                Console.WriteLine("[warn] Missing key type handler for {0}", key);
            }
            else
            {
                Console.WriteLine("[warn] Missing property: {0} = {1}", key, jsonElement.GetRawText());
#endif
            }

            // Failed to find a property
            return false;
        }

        /// <summary>
        /// Convert this instance to a JSON text
        /// </summary>
        /// <returns>JSON object</returns>
        public override string ToString() => JsonSerializer.Serialize(this, Utility.JsonHelper.DefaultJsonOptions);

        /// <summary>
        /// Serialize this instance to a UTF-8 string
        /// </summary>
        /// <returns></returns>
        public byte[] ToUtf8Json() => JsonSerializer.SerializeToUtf8Bytes(this, Utility.JsonHelper.DefaultJsonOptions);
    }
}